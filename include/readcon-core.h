#ifndef READCON_H
#define READCON_H

#pragma once

/* Generated with cbindgen:0.29.0 */

/* Warning, this file is autogenerated by cbindgen. Don't modify this manually. */

#include <stdarg.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>

#ifdef __cplusplus
namespace readcon {
#endif  // __cplusplus

/**
 * An iterator that lazily parses simulation frames from a `.con` file's contents.
 *
 * This struct wraps an iterator over the lines of a string and, upon each iteration,
 * attempts to parse a complete `ConFrame`. This is the primary interface for reading
 * data from a `.con` file.
 *
 * The iterator yields items of type `Result<ConFrame, ParseError>`, allowing for
 * robust error handling for each frame.
 */
typedef struct ConFrameIterator ConFrameIterator;

typedef struct String String;

typedef struct CConFrameIterator {
    struct ConFrameIterator *iterator;
    struct String *file_contents;
} CConFrameIterator;

/**
 * An opaque handle to a full, lossless Rust `ConFrame` object.
 * The C/C++ side should treat this as a void pointer.
 */
typedef struct RKRConFrame {
    uint8_t _private[0];
} RKRConFrame;

typedef struct CAtom {
    uint64_t atomic_number;
    double x;
    double y;
    double z;
    uint64_t atom_id;
    double mass;
    bool is_fixed;
} CAtom;

/**
 * A transparent, "lossy" C-struct containing only the core atomic data.
 * This can be extracted from an `RKRConFrame` handle for direct data access.
 * The caller is responsible for freeing the `atoms` array using `free_c_frame_atoms`.
 */
typedef struct CFrame {
    struct CAtom *atoms;
    uintptr_t num_atoms;
    double cell[3];
    double angles[3];
} CFrame;

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

/**
 * Creates a new iterator for a .con file.
 * The caller OWNS the returned pointer and MUST call `free_con_frame_iterator`.
 */
struct CConFrameIterator *read_con_file_iterator(const char *filename_c);

/**
 * Reads the next frame from the iterator, returning an opaque handle.
 * The caller OWNS the returned handle and must free it with `free_rkr_frame`.
 * Returns NULL if there are no more frames or on error.
 */
struct RKRConFrame *con_frame_iterator_next(struct CConFrameIterator *iterator);

/**
 * Frees the memory for an opaque `RKRConFrame` handle.
 */
void free_rkr_frame(struct RKRConFrame *frame_handle);

/**
 * Frees the memory for a `CConFrameIterator`.
 */
void free_con_frame_iterator(struct CConFrameIterator *iterator);

/**
 * Extracts the core atomic data into a transparent `CFrame` struct.
 * The caller OWNS the returned pointer and MUST call `free_c_frame` on it.
 */
struct CFrame *rkr_frame_to_c_frame(const struct RKRConFrame *frame_handle);

/**
 * Frees the memory of a `CFrame` struct, including its internal atoms array.
 */
void free_c_frame(struct CFrame *frame);

/**
 * Copies a header string line into a user-provided buffer.
 * Returns the number of bytes written (excluding null terminator), or -1 on error.
 */
int32_t rkr_frame_get_header_line(const struct RKRConFrame *frame_handle,
                                  bool is_prebox,
                                  uintptr_t line_index,
                                  char *buffer,
                                  uintptr_t buffer_len);

/**
 * Writes an array of RKRConFrame handles to a single file.
 *
 * This is the efficient way to write a multi-frame .con file from C.
 * Returns 0 on success, -1 on error.
 */
int32_t write_rkr_frames_to_file(const struct RKRConFrame *const *frame_handles,
                                 uintptr_t num_frames,
                                 const char *filename_c);

/**
 * Writes a single frame (given by its opaque handle) to the specified file.
 * Returns 0 on success, -1 on error.
 */
int32_t write_single_rkr_frame(const struct RKRConFrame *frame_handle,
                               const char *filename_c);

#ifdef __cplusplus
}  // extern "C"
#endif  // __cplusplus

#ifdef __cplusplus
}  // namespace readcon
#endif  // __cplusplus

#endif  /* READCON_H */
