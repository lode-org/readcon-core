#ifndef READCON_H
#define READCON_H

#pragma once

/* Generated with cbindgen:0.29.0 */

/* Warning, this file is autogenerated by cbindgen. Don't modify this manually. */

#include <stdarg.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>

#ifdef __cplusplus
namespace readcon {
#endif  // __cplusplus

/**
 * An iterator that lazily parses simulation frames from a `.con` file's contents.
 *
 * This struct wraps an iterator over the lines of a string and, upon each iteration,
 * attempts to parse a complete `ConFrame`. This is the primary interface for reading
 * data from a `.con` file.
 *
 * The iterator yields items of type `Result<ConFrame, ParseError>`, allowing for
 * robust error handling for each frame.
 */
typedef struct ConFrameIterator ConFrameIterator;

typedef struct String String;

typedef struct CConFrameIterator {
    struct ConFrameIterator *iterator;
    struct String *file_contents;
} CConFrameIterator;

/**
 * An opaque handle to a full, lossless Rust `ConFrame` object.
 * The C/C++ side needs to treat this as a void pointer
 */
typedef struct RKRConFrame {
    uint8_t _private[0];
} RKRConFrame;

typedef struct CAtom {
    uint64_t atomic_number;
    double x;
    double y;
    double z;
    uint64_t atom_id;
    double mass;
    bool is_fixed;
} CAtom;

/**
 * A transparent, "lossy" C-struct containing only the core atomic data.
 * This can be extracted from an `RKRConFrame` handle for direct data access.
 * The caller is responsible for freeing the `atoms` array using `free_c_frame`.
 */
typedef struct CFrame {
    struct CAtom *atoms;
    uintptr_t num_atoms;
    double cell[3];
    double angles[3];
} CFrame;

/**
 * An opaque handle to a Rust `ConFrameWriter` object.
 * The C/C++ side needs to treat this as a void pointer
 */
typedef struct RKRConFrameWriter {
    uint8_t _private[0];
} RKRConFrameWriter;

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

/**
 * Creates a new iterator for a .con file.
 * The caller OWNS the returned pointer and MUST call `free_con_frame_iterator`.
 * Returns NULL if there are no more frames or on error.
 */
struct CConFrameIterator *read_con_file_iterator(const char *filename_c);

/**
 * Reads the next frame from the iterator, returning an opaque handle.
 * The caller OWNS the returned handle and must free it with `free_rkr_frame`.
 */
struct RKRConFrame *con_frame_iterator_next(struct CConFrameIterator *iterator);

/**
 * Frees the memory for an opaque `RKRConFrame` handle.
 */
void free_rkr_frame(struct RKRConFrame *frame_handle);

/**
 * Frees the memory for a `CConFrameIterator`.
 */
void free_con_frame_iterator(struct CConFrameIterator *iterator);

/**
 * Extracts the core atomic data into a transparent `CFrame` struct.
 * The caller OWNS the returned pointer and MUST call `free_c_frame` on it.
 */
struct CFrame *rkr_frame_to_c_frame(const struct RKRConFrame *frame_handle);

/**
 * Frees the memory of a `CFrame` struct, including its internal atoms array.
 */
void free_c_frame(struct CFrame *frame);

/**
 * Copies a header string line into a user-provided buffer.
 * This is a C style helper... where the user explicitly sets the buffer.
 * Returns the number of bytes written (excluding null terminator), or -1 on error.
 */
int32_t rkr_frame_get_header_line(const struct RKRConFrame *frame_handle,
                                  bool is_prebox,
                                  uintptr_t line_index,
                                  char *buffer,
                                  uintptr_t buffer_len);

/**
 * Gets a header string line as a newly allocated, null-terminated C string.
 *
 * The caller OWNS the returned pointer and MUST call `rkr_free_string` on it
 * to prevent a memory leak. Returns NULL on error or if the index is invalid.
 */
char *rkr_frame_get_header_line_cpp(const struct RKRConFrame *frame_handle,
                                    bool is_prebox,
                                    uintptr_t line_index);

/**
 * Frees a C string that was allocated by Rust (e.g., from `rkr_frame_get_header_line`).
 */
void rkr_free_string(char *s);

/**
 * Creates a new frame writer for the specified file.
 * The caller OWNS the returned pointer and MUST call `free_rkr_writer`.
 */
struct RKRConFrameWriter *create_writer_from_path_c(const char *filename_c);

/**
 * Frees the memory for an `RKRConFrameWriter`, closing the associated file.
 */
void free_rkr_writer(struct RKRConFrameWriter *writer_handle);

/**
 * Writes multiple frames from an array of handles to the file managed by the writer.
 */
int32_t rkr_writer_extend(struct RKRConFrameWriter *writer_handle,
                          const struct RKRConFrame *const *frame_handles,
                          uintptr_t num_frames);

#ifdef __cplusplus
}  // extern "C"
#endif  // __cplusplus

#ifdef __cplusplus
}  // namespace readcon
#endif  // __cplusplus

#endif  /* READCON_H */
